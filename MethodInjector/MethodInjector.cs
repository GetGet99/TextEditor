namespace MethodInjector;

// This file is mostly generated by ChatGPT. Some modifications are made to make sure this code works.

using System;
using System.Collections.Generic;

public delegate TReturn ExternalMethod<TClass, TParam, TReturn>(TClass obj, TParam param);
public delegate TReturn ExternalMethodWithBase<TClass, TParam, TReturn>(TClass obj, TParam param, BaseMethod<TParam, TReturn> baseCaller);
public delegate TReturn BaseMethod<TParam, TReturn>(TParam param);

public class ExternalMethodManager<TClass, TParam, TReturn>
{
    private readonly Dictionary<Type, ExternalMethodWithBase<TClass, TParam, TReturn>> customMethods = new();
    public ExternalMethodManager() { }
    public ExternalMethodManager(ExternalMethod<TClass, TParam, TReturn> baseImplementation)
    {
        Register(baseImplementation);
    }
    public TReturn Call(TClass obj, TParam param)
        => Call(obj!.GetType(), obj, param);

    TReturn Call(Type objTypeToConsider, TClass obj, TParam param)
    {

        // Try to find a custom method for the specific type or its ancestors.
        while (objTypeToConsider != null)
        {
            if (customMethods.TryGetValue(objTypeToConsider, out var customMethod))
            {
                return customMethod(obj, param, (p => Call(objTypeToConsider.BaseType, obj, p)));
            }
            if (objTypeToConsider == typeof(TClass)) break;
            objTypeToConsider = objTypeToConsider.BaseType;
        }

        throw new InvalidOperationException("There are no class handled for the type of your object.");
    }

    public void Register<TSubClass>(ExternalMethodWithBase<TSubClass, TParam, TReturn> func) where TSubClass : TClass
    {
        customMethods[typeof(TSubClass)] = (obj, param, @base) => func((TSubClass)obj!, param, @base);
    }
    public void Register<TSubClass>(ExternalMethod<TSubClass, TParam, TReturn> func) where TSubClass : TClass
    {
        customMethods[typeof(TSubClass)] = (obj, param, @base) => func((TSubClass)obj!, param);
    }
}
